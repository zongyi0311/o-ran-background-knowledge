- [5.1 CRC calculation](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#51-crc-calculation)
- [5.2 Code block segmentation and CRC](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#52-code-block-segmentation-and-crc)
  - 5.2.1 Polar coding
  - 5.2.2 LDPC coding
  - Used for PDSCH/PUSCH
  - When the maximum code length of LDPC is exceeded (8448 bits), segmentation will be performed and a 24-bit CRC will be attached to each block.
- [5.3 Channel coding](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#53-channel-coding)
  - [5.3.1 Polar coding](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#polar-coding-nr_polar_interleaving_patternc)
    - [5.3.1.1 Interleaving](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#interleaving)
    - [5.3.1.2 Polar encoding](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#5312-polar-encoding)
  - [5.3.2 LDPC coding](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#low-density-parity-check-coding-nr_segmentationc)
    - Use base graph 1 or base graph 2
    - Map CB to LDPC parity-check matrix
    - Generate system bits and parity bits
- [5.4 Rate matching](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#54-rate-matching)
  - [5.4.1 Polar code](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#541-rate-matching-for-polar-code)
    - Sub-block interleaving: scattering bits
    - Bit selection: puncturing or repetition according to the transmission size
    - Interleaving: coded bits are scattered again
  - 5.4.2 LDPC code
    - Bit selection
    - Bit interleaving
  - 5.4.3 Small block 
- 5.5 Code block concatenation

- 6.1 Random Access Channel
- 6.2 Uplink Shared Channel
- 6.3 Uplink Control Information

- 7.1 Broadcast Channel
  - 7.1.1 PBCH Payload Generation
  - 7.1.2 Scrambling
  - 7.1.3 CRC 
  - 7.1.4 Channel Coding
  - 7.1.5 Rate Matching

- 7.2 Downlink Shared Channel & Paging Channel
  - 7.2.1 CRC
  - 7.2.2 LDPC Base Graph
  - 7.2.3 CB segmentation and CRC
  - 7.2.4 Channel Coding
  - 7.2.5 Rate Matching
  - 7.2.6 CB Merger
 
- 7.3 Downlink Control Information
  - 7.3.1 DCI Formats
  - 7.3.2 CRC
  - 7.3.3 Channel Coding
  - 7.3.4 Rate Matching

# 5.1 CRC calculation
## Cyclic Redundancy Check (CRC) is used to detect errors in a transmitted bit sequence.

- **Input bits**: `a₀, a₁, ..., aₐ₋₁`
- **CRC bits**: `p₀, p₁, ..., pₗ₋₁`
- \( A \) = length of input sequence  
- \( L \) = length of CRC (number of parity bits)  
The CRC is calculated using a **generator polynomial** and appended to the message.

---

##  Generator Polynomials

| Name        | Polynomial Expression                                                                                             | Length |
|-------------|--------------------------------------------------------------------------------------------------------------------|--------|
| $g_CRC24A$  | $D^{24} + D^{23} + D^{18} + D^{17} + D^{14} + D^{11} + D^{10} + D^7 + D^6 + D^5 + D^4 + D^3 + D + 1$          | 24     |
| $g_CRC24B$  | $D^{24} + D^3 + D^6 + D^5 + D + 1$                                                                            | 24     |
| $g_CRC24C$  | $D^{24} + D^{23} + D^{21} + D^{20} + D^{17} + D^{15} + D^{13} + D^{12} + D^8 + D^4 + D^2 + D + 1 $            | 24     |
| $g_CRC16$   | $D^{16} + D^{12} + D^5 + 1$                                                                                   | 16     |
| $g_CRC11$   | $D^{11} + D^{10} + D^9 + D^5 + 1$                                                                             | 11     |
| $g_CRC6$    | $D^6 + D^5 + 1$                                                                                               | 6      |


---

##  Systematic Encoding Principle

The encoded sequence is constructed so that the **polynomial representation** of the bits (in GF(2)) is divisible by the CRC polynomial:

$$
a_0 D^{A+L-1} + a_1 D^{A+L-2} + \cdots + a_{A-1} D^L + p_0 D^{L-1} + \cdots + p_{L-1}
$$


This yields a **remainder of 0** when divided by the generator polynomial.

---

##  Output Sequence with CRC

Let:
- \( B = A + L \)
- Output bits: $b_0, b_1, ..., b_{B-1}$

Then:
- $b_k = a_k$ for $k = 0, ..., A-1$
- $b_k = p_{k - A}$ for $k = A, ..., A + L - 1$

This means the **original data is followed by the CRC**.

---

- CRC is used to detect transmission errors.
- It is computed using predefined polynomials.
- The CRC bits are appended to the end of the data (systematic encoding).
- The polynomial representation is divisible by the CRC polynomial without remainder.

## example crc_byte.c/crc24a()
```
uint32_t crc24a(unsigned char* inptr, int bitlen)
{
  int octetlen = bitlen / 8;  /* Change in octets */

  if ( bitlen % 8 || !USE_INTEL_CRC ) {
    uint32_t crc = 0;
    int resbit = (bitlen % 8);

    while (octetlen-- > 0) {
      //   printf("crc24a: in %x => crc %x\n",crc,*inptr);
      crc = (crc << 8) ^ crc24aTable[(*inptr++) ^ (crc >> 24)];//	Byte-wise CRC using XOR and crc24aTable[]
    }

  if (resbit > 0)
    crc = (crc << resbit) ^ crc24aTable[((*inptr) >> (8 - resbit)) ^ (crc >> (32 - resbit))];
  return crc;
  }
  #if defined(__SSE4_1__) || defined(__aarch64__) 
  else {
  return crc32_calc_pclmulqdq(inptr, octetlen, 0,
                              &lte_crc24a_pclmulqdq);
  }
  #endif

}
```

# 5.2 Code block segmentation and CRC
**5.2.1 Polar coding**
## 1. Determine number of code blocks `C`
```
if I_seg == 1:
    C = 2
else:
    C = 1
```
## 2. Padding input to fit segments
```
A' = ceil(A / C) × C   // total padded length

for i = 0 to A' - A - 1:
    a'_i = 0            // zero padding

for i = A' - A to A' - 1:
    a'_i = a_{i - (A' - A)}
```

## 3. Split into C code blocks
```
s = 0
for r = 0 to C - 1:
    for k = 0 to (A'/C - 1):
        c_k = a'_s
        s = s + 1

```
## 4. Add CRC to each code block
- Use the CRC calculation from Section 5.1, with a generator polynomial of length L, to calculate:
```
P = [p₀, p₁, ..., p_{L-1}]
```
---

**Low density parity check coding**
## Input Sequence
- b0, b1, b2, ..., b(B-1) Where B > 0.

## Step 1: Determine if Segmentation is Needed 
**//nr_segmentation.c 42~60**
- Let K_cb be the maximum LDPC code block size depending on the base graph:

| LDPC Base Graph | `K_cb` (max size) |
| --------------- | ----------------- |
| Graph 1         | 8448              |
| Graph 2         | 3840              |

-  If B ≤ K_cb
  -  No segmentation required
  -  C = 1, L = 0, B' = B

-  If B > K_cb
  -  Segmentation is required
```
L = 24
C = ceil(B / (K_cb - L))
B' = B + C * L
```

## Step 2: Compute Intermediate Block Size
```
K' = B' / C
example:
 // Find K+
  Kprime = Bprime/(*C);
```

## Step 3: Determine Lifting Size Z_c and Final Block Size K
- For Base Graph 1:
```
K_b = 22
K = 22 * Z_c
```


- For Base Graph 2:
```
{
    if (B > 640) {
      Kb = 10;
    } else if (B > 560) {
      Kb = 9;
    } else if (B > 192) {
      Kb = 8;
    }
    else {
      Kb = 6;
    }
  }
```
**//147~167**
## Step 4: Fill Code Blocks with Data Bits
```
s = 0;
for (r = 0; r < C; r++) {
  for (k = 0; k < K' - L; k++) {
    c_k = b_s;
    s++;
  }
}
```
## Step 5:Append CRC to Each Block (if C > 1)
```
for (k = K' - L; k < K'; k++) {
  c_k = p_{k + L - K'};
}
```

## Step 6: Insert Filler Bits (if K > K')
```
for (k = K'; k < K; k++) {
  c_k = <NULL>;  // Not transmitted
}
```

# 5.3 Channel coding 
- Channel Coding for Transport Channels (TrCHs)

| **Transport Channel (TrCH)**     | **Coding Scheme** |
| -------------------------------- | ----------------- |
| UL-SCH (Uplink Shared Channel)   | LDPC              |
| DL-SCH (Downlink Shared Channel) | LDPC              |
| PCH (Paging Channel)             | LDPC              |
| BCH (Broadcast Channel)          | Polar code        |

- Channel Coding for Control Information

| **Control Information**            | **Coding Scheme**       |
| ---------------------------------- | ----------------------- |
| DCI (Downlink Control Information) | Polar code              |
| UCI (Uplink Control Information)   | Block code / Polar code |


## Polar coding 
**//nr_polar_interleaving_pattern.c**
- Input and Output

<img width="747" height="120" alt="image" src="https://github.com/user-attachments/assets/15f55421-1095-46e0-8d68-a1c2b472ec71" />

<img width="747" height="611" alt="image" src="https://github.com/user-attachments/assets/a823b05f-d35a-4ec6-92d8-df10c3d18fd0" />

## Interleaving
The bit sequence `c₀, c₁, c₂, ..., cₖ₋₁` is interleaved into a new bit sequence `c'₀, c'₁, ..., c'ₖ₋₁` as:
c'k = c{Π(k)}, for k = 0, 1, ..., K−1

Where `Π(k)` is the interleaving pattern determined as follows:
```
Case 1: No interleaving applied (`I_IL = 0`)
Π(k) = k, for k = 0, 1, ..., K−1

Case 2: Interleaving applied (`I_IL = 1`)
k = 0;
for (m = 0; m < K_IL_max; m++) {
    if (Π_IL_max(m) ≥ K_IL_max − K) {
        Π(k) = Π_IL_max(m) − (K_IL_max − K);
        k = k + 1;
    }
}
```
- K is the number of input bits to interleave.
- K_IL_max = 164
- Π_IL_max(m) is a pre-defined permutation sequence from Table 5.3.1.1-1.
-Table 5.3.1.1-1: Interleaving pattern


## 5.3.1.2 Polar encoding 
**//nr_polar_sequence_pattern.c**
```
 Polar Sequence Definition 

The Polar sequence `Q₀ⁿₐₓ₋₁ = {Q₀, Q₁, ..., Qₙₐₓ₋₁}` is defined in Table 5.3.1.2-1, where:
- `0 ≤ Qᵢ ≤ Nₘₐₓ − 1`
- `Nₘₐₓ = 1024`

This sequence is ordered by increasing reliability:
W(Q₀) < W(Q₁) < ... < W(Qₙₐₓ₋₁)

where `W(Qᵢ)` denotes the reliability of bit index `Qᵢ`.

---

N-bit Polar Encoding

To encode a code block of length `N`, a sub-sequence `Q₀ⁿ⁻¹ = {Q₀, Q₁, ..., Qₙ₋₁}` is used, consisting of all values in `Q₀ⁿₐₓ₋₁` less than `N`, also ordered by reliability:
W(Q₀ⁿ) < W(Q₁ⁿ) < ... < W(Qₙ₋₁ⁿ)

Definitions
- Let `Q̅_Iⁿ` be the set of bit indices used for **information and CRC bits**  
- Let `Q̅_Fⁿ` be the set of indices used for **frozen bits**
These are defined by:
|Q̅_Iⁿ| = K + n_PC
|Q̅_Fⁿ| = N − |Q̅_Iⁿ|

Encoding Matrix
The encoding uses the Kronecker product of the base matrix `G₂`:
G_N = (G₂)^(⊗n), where G₂ = [[1, 0],[1, 1]]

CRC Bit Placement
Let:
- `gⱼ` be the j-th row of `G_N`
- `w(gⱼ)` be the row weight (number of 1s in `gⱼ`)

CRC bit index selection:
1. Define a set `Q_PCⁿ` of length `n_PC` for parity check bits:|Q_PCⁿ| = n_PC
2. Place `n_PC − n_PC^wm` CRC bits in the `n_PC − n_PC^wm` least reliable indices of `Q̅_Iⁿ`.
3. Place `n_PC^wm` CRC bits in the indices of **minimum row weight** from `Q̅_Iⁿ`.  
- If there are more than `n_PC^wm` such positions, select the **most reliable** among them.

| Parameter     | Description                                      |
|---------------|--------------------------------------------------|
| `Q₀ⁿₐₓ₋₁`     | Polar sequence ordered by increasing reliability |
| `Q̅_Iⁿ`       | Bit indices for information and CRC              |
| `Q̅_Fⁿ`       | Bit indices for frozen bits                      |
| `G_N`         | Polar encoding matrix via Kronecker product      |
| `w(gⱼ)`       | Row weight of row `gⱼ` of `G_N`                  |
| `Q_PCⁿ`       | CRC bit indices                                  |
| `n_PC^wm`     | CRC bits placed at min-weight positions          |

```
--- 

**Polar Encoding Process**

- 1.Initialization
- 2.If n_PC > 0 (parity bits present):

```
//nr_polar_procedure.c/nr_polar_generate_u
y0 = 0;
y1 = 0;
y2 = 0;
y3 = 0;
y4 = 0;

for (n = 0; n < N; n++) {
    yt = y0;
    y0 = y1;
    y1 = y2;
    y2 = y3;
    y3 = y4;
    y4 = yt;

    if (n in QI^N) {
        if (n in Q_PC^N) {
            u[n] = y0;
        } else {
            u[n] = c[k];
            k += 1;
            y0 = y0 ⊕ u[n];
        }
    } else {
        u[n] = 0;
    }
}
3. Else (n_PC == 0, no parity bits):
for (n = 0; n < N; n++) {
    if (n in QI^N) {
        u[n] = c[k];
        k += 1;
    } else {
        u[n] = 0;
    }
}

```
- 4.Final Encoding Output

```
void nr_polar_uxG(uint8_t const *u, size_t N, uint8_t *D2)
{
  assert(N > 7);
  uint8_t tmp[N / 8];
  for (int i = 0; i < N / 8; ++i)
    tmp[i] = u[N / 8 - 1 - i];

  reverse_bits_u8(tmp, N / 8, D2);

  // Do the encoding/xor for the bottom 3 levels of the tree.
  // Thus, data remaining to encode, is in 2^3 type.
  polar_encode_bits(D2, N);
  // Xor the remaining tree levels. Use bytes for it
  polar_encode_bytes(D2, N);
}
```

## Low density parity check coding 
**//nr_segmentation.c**
<img width="780" height="308" alt="image" src="https://github.com/user-attachments/assets/b08546af-9a25-4b0c-8c75-a11cf57a8e4f" />

//Table 5.3.2-1: Sets of LDPC lifting size Z
- Step 1: Lifting Size Set Index
  - Find the index i_LS in Table 5.3.2-1 which contains Zc.
- Step 2: Initialization (Systematic Bits)

```
for k = 2*Zc to K-1:
    if c[k] ≠ NULL:
        d[k - 2*Zc] = c[k]
    else:
        c[k] = 0
        d[k - 2*Zc] = NULL

```

- Step 3: Generate Parity Bits
- Generate N + 22Zc - K parity bits w = [w₀, w₁, ..., wₙ₊₂₂Zc₋ₖ₋₁] such that:

```
H × [ cᵗ wᵗ ] = 0
```

<img width="780" height="580" alt="image" src="https://github.com/user-attachments/assets/53378984-9dd3-4834-9b4d-aae44668b94e" />

- Step 4: Fill Final Encoded Bits


```
for k = K to N + 2*Zc - 1:
    d[k - 2*Zc] = w[k - K]
```

## 5.4 Rate matching
## 5.4.1 Rate Matching for Polar Code

## 5.4.1.1 Sub-block interleaving 
- Rate matching for Polar code is applied **per coded block**.

- It includes three steps:
  - 1. Sub-block interleaving
  - 2. Bit collection
  - 3. Bit interleaving
- Input bit sequence for rate matching:  
  `d₀, d₁, d₂, ..., dₙ₋₁`
- Output bit sequence after rate matching:  
  `f₀, f₁, f₂, ..., fₑ₋₁`

<img width="578" height="176" alt="image" src="https://github.com/user-attachments/assets/7c6e14b2-78f8-408e-bbf6-23d46a3794ab" />

<img width="554" height="117" alt="image" src="https://github.com/user-attachments/assets/dea319c4-4943-4bc6-b358-83a93078b5d9" />

## 5.4.1.2 Bit selection
- After sub-block interleaving, the output bit sequence y₀, y₁, y₂, ..., yₙ₋₁ (from Clause 5.4.1.1) is stored in a circular buffer of length N.
  - E: the rate-matching output sequence length
  - eₖ: the output bit after bit selection, where k = 0, 1, ..., E−1
 
- nr_polar_procedures.c

```
void nr_polar_rate_matching_pattern(uint16_t *rmp, uint16_t *J, const uint8_t *P_i_, uint16_t K, uint16_t N, uint16_t E)
{
  uint16_t d[N];
  for (int m = 0; m < N; m++)
    d[m] = m;
  uint16_t y[N];
  memset(y, 0, sizeof(y));

  for (int m = 0; m <= N - 1; m++) {//Sub-block interleaving 
    int i = floor((32 * m) / N);
    J[m] = (P_i_[i] * (N / 32)) + (m % (N / 32));
    y[m] = d[J[m]];
  }
 //Bit selection
  if (E >= N) { // repetition 
    for (int k = 0; k <= E - 1; k++) {
      int ind = (k % N);
      rmp[k] = y[ind];
    }
  } else {
    if ((K / (double)E) <= (7.0 / 16)) { // puncturing
      for (int k = 0; k <= E - 1; k++) {
        rmp[k] = y[k + N - E];
      }
    } else { // shortening
      for (int k = 0; k <= E - 1; k++) {
        rmp[k] = y[k];
      }
    }
  }
}
```

## 5.4.1.3 Interleaving of coded bits
nr_polar_encoder.c
```
void nr_polar_rm_interleaving_cb(void *in, void *out, uint16_t E)
{
  int T = ceil((sqrt(8 * E + 1) - 1) / 2);
  int v[T][T];
  int k = 0;
  uint64_t *in64 = (uint64_t *)in;
  for (int i = 0; i < T; i++) {
    for (int j = 0; j < T - i; j++) {
      if (k < E) {
        int k1 = k >> 6;
        int k2 = k - (k1 << 6);
        v[i][j] = (in64[k1] >> k2) & 1;
      } else {
        v[i][j] = -1;
      }
      k++;
    }
  }
  k = 0;
  uint64_t *out64 = (uint64_t *)out;
  memset(out64, 0, E >> 3);
  for (int j = 0; j < T; j++) {
    for (int i = 0; i < T - j; i++) {
      if (v[i][j] != -1) {
        int k1 = k >> 6;
        int k2 = k - (k1 << 6);
        out64[k1] |= (uint64_t)v[i][j] << k2;
        k++;
      }
    }
  }
}

```
