- [5.1 CRC calculation](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#51-crc-calculation)
- [5.2 Code block segmentation and CRC](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#52-code-block-segmentation-and-crc)
  - 5.2.1 Polar coding
  - 5.2.2 LDPC coding
  - Used for PDSCH/PUSCH
  - When the maximum code length of LDPC is exceeded (8448 bits), segmentation will be performed and a 24-bit CRC will be attached to each block.
- [5.3 Channel coding](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#53-channel-coding)
  - [5.3.1 Polar coding](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#polar-coding-nr_polar_interleaving_patternc)
    - [5.3.1.1 Interleaving](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#interleaving)
    - [5.3.1.2 Polar encoding](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#5312-polar-encoding)
  - [5.3.2 LDPC coding](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#low-density-parity-check-coding)
    - Use base graph 1 or base graph 2
    - Map CB to LDPC parity-check matrix
    - Generate system bits and parity bits
- [5.4 Rate matching](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#54-rate-matching)
  - [5.4.1 Polar code](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#541-rate-matching-for-polar-code)
    - Sub-block interleaving: scattering bits
    - Bit selection: puncturing or repetition according to the transmission size
    - Interleaving: coded bits are scattered again
  - [5.4.2 Rate matching for LDPC code](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#542-rate-matching-for-ldpc-code)
    - Bit selection
    - Bit interleaving
- [5.5 Code block concatenation](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#55-code-block-concatenation)

- 6.1 Random Access Channel
- 6.2 Uplink Shared Channel
- 6.3 Uplink Control Information

- [7.1 Broadcast Channel](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#71-broadcast-channel)
  - [7.1.1 PBCH Payload Generation](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#711-pbch-payload-generation)
  - [7.1.2 Scrambling](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#712-scrambling)
  - [7.1.3 CRC](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#715-rate-matching)
  - [7.1.4 Channel Coding](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#715-rate-matching)
  - [7.1.5 Rate Matching](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#715-rate-matching)

- [7.2 Downlink Shared Channel & Paging Channel](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#72-downlink-shared-channel-and-paging-channel)
  - [7.2.1 CRC](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#721-transport-block-crc-attachment)
  - [7.2.2 LDPC Base Graph](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#722-ldpc-base-graph-selection)
  - [7.2.3 CB segmentation and CRC](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#723-code-block-segmentation-and-code-block-crc-attachment)
  - [7.2.4 Channel Coding](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#724-channel-coding)
  - [7.2.5 Rate Matching](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#725-rate-matching)
  - 7.2.6 [CB Merger](https://github.com/zongyi0311/rfsim-intern-log/blob/main/3GPP/TS%2038%20212.md#726-code-block-concatenation)
 
- 7.3 Downlink Control Information
  - 7.3.1 DCI Formats
  - 7.3.2 CRC
  - 7.3.3 Channel Coding
  - 7.3.4 Rate Matching

# 5.1 CRC calculation
## Cyclic Redundancy Check (CRC) is used to detect errors in a transmitted bit sequence.

- **Input bits**: `a₀, a₁, ..., aₐ₋₁`
- **CRC bits**: `p₀, p₁, ..., pₗ₋₁`
- \( A \) = length of input sequence  
- \( L \) = length of CRC (number of parity bits)  
The CRC is calculated using a **generator polynomial** and appended to the message.

---

##  Generator Polynomials

| Name        | Polynomial Expression                                                                                             | Length |
|-------------|--------------------------------------------------------------------------------------------------------------------|--------|
| $g_CRC24A$  | $D^{24} + D^{23} + D^{18} + D^{17} + D^{14} + D^{11} + D^{10} + D^7 + D^6 + D^5 + D^4 + D^3 + D + 1$          | 24     |
| $g_CRC24B$  | $D^{24} + D^3 + D^6 + D^5 + D + 1$                                                                            | 24     |
| $g_CRC24C$  | $D^{24} + D^{23} + D^{21} + D^{20} + D^{17} + D^{15} + D^{13} + D^{12} + D^8 + D^4 + D^2 + D + 1 $            | 24     |
| $g_CRC16$   | $D^{16} + D^{12} + D^5 + 1$                                                                                   | 16     |
| $g_CRC11$   | $D^{11} + D^{10} + D^9 + D^5 + 1$                                                                             | 11     |
| $g_CRC6$    | $D^6 + D^5 + 1$                                                                                               | 6      |


---

##  Systematic Encoding Principle

The encoded sequence is constructed so that the **polynomial representation** of the bits (in GF(2)) is divisible by the CRC polynomial:

$$
a_0 D^{A+L-1} + a_1 D^{A+L-2} + \cdots + a_{A-1} D^L + p_0 D^{L-1} + \cdots + p_{L-1}
$$


This yields a **remainder of 0** when divided by the generator polynomial.

---

##  Output Sequence with CRC

Let:
- \( B = A + L \)
- Output bits: $b_0, b_1, ..., b_{B-1}$

Then:
- $b_k = a_k$ for $k = 0, ..., A-1$
- $b_k = p_{k - A}$ for $k = A, ..., A + L - 1$

This means the **original data is followed by the CRC**.

---

- CRC is used to detect transmission errors.
- It is computed using predefined polynomials.
- The CRC bits are appended to the end of the data (systematic encoding).
- The polynomial representation is divisible by the CRC polynomial without remainder.

## example crc_byte.c/crc24a()
```
uint32_t crc24a(unsigned char* inptr, int bitlen)
{
  int octetlen = bitlen / 8;  /* Change in octets */

  if ( bitlen % 8 || !USE_INTEL_CRC ) {
    uint32_t crc = 0;
    int resbit = (bitlen % 8);

    while (octetlen-- > 0) {
      //   printf("crc24a: in %x => crc %x\n",crc,*inptr);
      crc = (crc << 8) ^ crc24aTable[(*inptr++) ^ (crc >> 24)];//	Byte-wise CRC using XOR and crc24aTable[]
    }

  if (resbit > 0)
    crc = (crc << resbit) ^ crc24aTable[((*inptr) >> (8 - resbit)) ^ (crc >> (32 - resbit))];
  return crc;
  }
  #if defined(__SSE4_1__) || defined(__aarch64__) 
  else {
  return crc32_calc_pclmulqdq(inptr, octetlen, 0,
                              &lte_crc24a_pclmulqdq);
  }
  #endif

}
```

# 5.2 Code block segmentation and CRC
**5.2.1 Polar coding**
## 1. Determine number of code blocks `C`
```
if I_seg == 1:
    C = 2
else:
    C = 1
```
## 2. Padding input to fit segments
```
A' = ceil(A / C) × C   // total padded length

for i = 0 to A' - A - 1:
    a'_i = 0            // zero padding

for i = A' - A to A' - 1:
    a'_i = a_{i - (A' - A)}
```

## 3. Split into C code blocks
```
s = 0
for r = 0 to C - 1:
    for k = 0 to (A'/C - 1):
        c_k = a'_s
        s = s + 1

```
## 4. Add CRC to each code block
- Use the CRC calculation from Section 5.1, with a generator polynomial of length L, to calculate:
```
P = [p₀, p₁, ..., p_{L-1}]
```
---

**Low density parity check coding**
## Input Sequence
- b0, b1, b2, ..., b(B-1) Where B > 0.

## Step 1: Determine if Segmentation is Needed 
**//nr_segmentation.c 42~60**
- Let K_cb be the maximum LDPC code block size depending on the base graph:

| LDPC Base Graph | `K_cb` (max size) |
| --------------- | ----------------- |
| Graph 1         | 8448              |
| Graph 2         | 3840              |

-  If B ≤ K_cb
  -  No segmentation required
  -  C = 1, L = 0, B' = B

-  If B > K_cb
  -  Segmentation is required
```
L = 24
C = ceil(B / (K_cb - L))
B' = B + C * L
```

## Step 2: Compute Intermediate Block Size
```
K' = B' / C
example:
 // Find K+
  Kprime = Bprime/(*C);
```

## Step 3: Determine Lifting Size Z_c and Final Block Size K
- For Base Graph 1:
```
K_b = 22
K = 22 * Z_c
```


- For Base Graph 2:
```
{
    if (B > 640) {
      Kb = 10;
    } else if (B > 560) {
      Kb = 9;
    } else if (B > 192) {
      Kb = 8;
    }
    else {
      Kb = 6;
    }
  }
```
**//147~167**
## Step 4: Fill Code Blocks with Data Bits
```
s = 0;
for (r = 0; r < C; r++) {
  for (k = 0; k < K' - L; k++) {
    c_k = b_s;
    s++;
  }
}
```
## Step 5:Append CRC to Each Block (if C > 1)
```
for (k = K' - L; k < K'; k++) {
  c_k = p_{k + L - K'};
}
```

## Step 6: Insert Filler Bits (if K > K')
```
for (k = K'; k < K; k++) {
  c_k = <NULL>;  // Not transmitted
}
```

# 5.3 Channel coding 
- Channel Coding for Transport Channels (TrCHs)

| **Transport Channel (TrCH)**     | **Coding Scheme** |
| -------------------------------- | ----------------- |
| UL-SCH (Uplink Shared Channel)   | LDPC              |
| DL-SCH (Downlink Shared Channel) | LDPC              |
| PCH (Paging Channel)             | LDPC              |
| BCH (Broadcast Channel)          | Polar code        |

- Channel Coding for Control Information

| **Control Information**            | **Coding Scheme**       |
| ---------------------------------- | ----------------------- |
| DCI (Downlink Control Information) | Polar code              |
| UCI (Uplink Control Information)   | Block code / Polar code |


## Polar coding 
**//nr_polar_interleaving_pattern.c**
- Input and Output

<img width="747" height="120" alt="image" src="https://github.com/user-attachments/assets/15f55421-1095-46e0-8d68-a1c2b472ec71" />

<img width="747" height="611" alt="image" src="https://github.com/user-attachments/assets/a823b05f-d35a-4ec6-92d8-df10c3d18fd0" />

## Interleaving
The bit sequence `c₀, c₁, c₂, ..., cₖ₋₁` is interleaved into a new bit sequence `c'₀, c'₁, ..., c'ₖ₋₁` as:
c'k = c{Π(k)}, for k = 0, 1, ..., K−1

Where `Π(k)` is the interleaving pattern determined as follows:
```
Case 1: No interleaving applied (`I_IL = 0`)
Π(k) = k, for k = 0, 1, ..., K−1

Case 2: Interleaving applied (`I_IL = 1`)
k = 0;
for (m = 0; m < K_IL_max; m++) {
    if (Π_IL_max(m) ≥ K_IL_max − K) {
        Π(k) = Π_IL_max(m) − (K_IL_max − K);
        k = k + 1;
    }
}
```
- K is the number of input bits to interleave.
- K_IL_max = 164
- Π_IL_max(m) is a pre-defined permutation sequence from Table 5.3.1.1-1.
-Table 5.3.1.1-1: Interleaving pattern


## 5.3.1.2 Polar encoding 
**//nr_polar_sequence_pattern.c**
```
 Polar Sequence Definition 

The Polar sequence `Q₀ⁿₐₓ₋₁ = {Q₀, Q₁, ..., Qₙₐₓ₋₁}` is defined in Table 5.3.1.2-1, where:
- `0 ≤ Qᵢ ≤ Nₘₐₓ − 1`
- `Nₘₐₓ = 1024`

This sequence is ordered by increasing reliability:
W(Q₀) < W(Q₁) < ... < W(Qₙₐₓ₋₁)

where `W(Qᵢ)` denotes the reliability of bit index `Qᵢ`.

---

N-bit Polar Encoding

To encode a code block of length `N`, a sub-sequence `Q₀ⁿ⁻¹ = {Q₀, Q₁, ..., Qₙ₋₁}` is used, consisting of all values in `Q₀ⁿₐₓ₋₁` less than `N`, also ordered by reliability:
W(Q₀ⁿ) < W(Q₁ⁿ) < ... < W(Qₙ₋₁ⁿ)

Definitions
- Let `Q̅_Iⁿ` be the set of bit indices used for **information and CRC bits**  
- Let `Q̅_Fⁿ` be the set of indices used for **frozen bits**
These are defined by:
|Q̅_Iⁿ| = K + n_PC
|Q̅_Fⁿ| = N − |Q̅_Iⁿ|

Encoding Matrix
The encoding uses the Kronecker product of the base matrix `G₂`:
G_N = (G₂)^(⊗n), where G₂ = [[1, 0],[1, 1]]

CRC Bit Placement
Let:
- `gⱼ` be the j-th row of `G_N`
- `w(gⱼ)` be the row weight (number of 1s in `gⱼ`)

CRC bit index selection:
1. Define a set `Q_PCⁿ` of length `n_PC` for parity check bits:|Q_PCⁿ| = n_PC
2. Place `n_PC − n_PC^wm` CRC bits in the `n_PC − n_PC^wm` least reliable indices of `Q̅_Iⁿ`.
3. Place `n_PC^wm` CRC bits in the indices of **minimum row weight** from `Q̅_Iⁿ`.  
- If there are more than `n_PC^wm` such positions, select the **most reliable** among them.

| Parameter     | Description                                      |
|---------------|--------------------------------------------------|
| `Q₀ⁿₐₓ₋₁`     | Polar sequence ordered by increasing reliability |
| `Q̅_Iⁿ`       | Bit indices for information and CRC              |
| `Q̅_Fⁿ`       | Bit indices for frozen bits                      |
| `G_N`         | Polar encoding matrix via Kronecker product      |
| `w(gⱼ)`       | Row weight of row `gⱼ` of `G_N`                  |
| `Q_PCⁿ`       | CRC bit indices                                  |
| `n_PC^wm`     | CRC bits placed at min-weight positions          |

```
--- 

**Polar Encoding Process**

- 1.Initialization
- 2.If n_PC > 0 (parity bits present):

```
//nr_polar_procedure.c/nr_polar_generate_u
y0 = 0;
y1 = 0;
y2 = 0;
y3 = 0;
y4 = 0;

for (n = 0; n < N; n++) {
    yt = y0;
    y0 = y1;
    y1 = y2;
    y2 = y3;
    y3 = y4;
    y4 = yt;

    if (n in QI^N) {
        if (n in Q_PC^N) {
            u[n] = y0;
        } else {
            u[n] = c[k];
            k += 1;
            y0 = y0 ⊕ u[n];
        }
    } else {
        u[n] = 0;
    }
}
3. Else (n_PC == 0, no parity bits):
for (n = 0; n < N; n++) {
    if (n in QI^N) {
        u[n] = c[k];
        k += 1;
    } else {
        u[n] = 0;
    }
}

```
- 4.Final Encoding Output

```
void nr_polar_uxG(uint8_t const *u, size_t N, uint8_t *D2)
{
  assert(N > 7);
  uint8_t tmp[N / 8];
  for (int i = 0; i < N / 8; ++i)
    tmp[i] = u[N / 8 - 1 - i];

  reverse_bits_u8(tmp, N / 8, D2);

  // Do the encoding/xor for the bottom 3 levels of the tree.
  // Thus, data remaining to encode, is in 2^3 type.
  polar_encode_bits(D2, N);
  // Xor the remaining tree levels. Use bytes for it
  polar_encode_bytes(D2, N);
}
```

## Low density parity check coding 
**//nr_segmentation.c**
<img width="780" height="308" alt="image" src="https://github.com/user-attachments/assets/b08546af-9a25-4b0c-8c75-a11cf57a8e4f" />

//Table 5.3.2-1: Sets of LDPC lifting size Z
- Step 1: Lifting Size Set Index
  - Find the index i_LS in Table 5.3.2-1 which contains Zc.
- Step 2: Initialization (Systematic Bits)

```
for k = 2*Zc to K-1:
    if c[k] ≠ NULL:
        d[k - 2*Zc] = c[k]
    else:
        c[k] = 0
        d[k - 2*Zc] = NULL

```

- Step 3: Generate Parity Bits
- Generate N + 22Zc - K parity bits w = [w₀, w₁, ..., wₙ₊₂₂Zc₋ₖ₋₁] such that:

```
H × [ cᵗ wᵗ ] = 0
```

<img width="780" height="580" alt="image" src="https://github.com/user-attachments/assets/53378984-9dd3-4834-9b4d-aae44668b94e" />

- Step 4: Fill Final Encoded Bits


```
for k = K to N + 2*Zc - 1:
    d[k - 2*Zc] = w[k - K]
```

## 5.4 Rate matching
## 5.4.1 Rate Matching for Polar Code

## 5.4.1.1 Sub-block interleaving 
- Rate matching for Polar code is applied **per coded block**.

- It includes three steps:
  - 1. Sub-block interleaving
  - 2. Bit collection
  - 3. Bit interleaving
- Input bit sequence for rate matching:  
  `d₀, d₁, d₂, ..., dₙ₋₁`
- Output bit sequence after rate matching:  
  `f₀, f₁, f₂, ..., fₑ₋₁`

<img width="578" height="176" alt="image" src="https://github.com/user-attachments/assets/7c6e14b2-78f8-408e-bbf6-23d46a3794ab" />

<img width="554" height="117" alt="image" src="https://github.com/user-attachments/assets/dea319c4-4943-4bc6-b358-83a93078b5d9" />

## 5.4.1.2 Bit selection
- After sub-block interleaving, the output bit sequence y₀, y₁, y₂, ..., yₙ₋₁ (from Clause 5.4.1.1) is stored in a circular buffer of length N.
  - E: the rate-matching output sequence length
  - eₖ: the output bit after bit selection, where k = 0, 1, ..., E−1
 
- nr_polar_procedures.c

```
void nr_polar_rate_matching_pattern(uint16_t *rmp, uint16_t *J, const uint8_t *P_i_, uint16_t K, uint16_t N, uint16_t E)
{
  uint16_t d[N];
  for (int m = 0; m < N; m++)
    d[m] = m;
  uint16_t y[N];
  memset(y, 0, sizeof(y));

  for (int m = 0; m <= N - 1; m++) {//Sub-block interleaving 
    int i = floor((32 * m) / N);
    J[m] = (P_i_[i] * (N / 32)) + (m % (N / 32));
    y[m] = d[J[m]];
  }
 //Bit selection
  if (E >= N) { // repetition 
    for (int k = 0; k <= E - 1; k++) {
      int ind = (k % N);
      rmp[k] = y[ind];
    }
  } else {
    if ((K / (double)E) <= (7.0 / 16)) { // puncturing
      for (int k = 0; k <= E - 1; k++) {
        rmp[k] = y[k + N - E];
      }
    } else { // shortening
      for (int k = 0; k <= E - 1; k++) {
        rmp[k] = y[k];
      }
    }
  }
}
```

## 5.4.1.3 Interleaving of coded bits
nr_polar_encoder.c
```
void nr_polar_rm_interleaving_cb(void *in, void *out, uint16_t E)
{
  int T = ceil((sqrt(8 * E + 1) - 1) / 2);
  int v[T][T];
  int k = 0;
  uint64_t *in64 = (uint64_t *)in;
  for (int i = 0; i < T; i++) {
    for (int j = 0; j < T - i; j++) {
      if (k < E) {
        int k1 = k >> 6;
        int k2 = k - (k1 << 6);
        v[i][j] = (in64[k1] >> k2) & 1;
      } else {
        v[i][j] = -1;
      }
      k++;
    }
  }
  k = 0;
  uint64_t *out64 = (uint64_t *)out;
  memset(out64, 0, E >> 3);
  for (int j = 0; j < T; j++) {
    for (int i = 0; i < T - j; i++) {
      if (v[i][j] != -1) {
        int k1 = k >> 6;
        int k2 = k - (k1 << 6);
        out64[k1] |= (uint64_t)v[i][j] << k2;
        k++;
      }
    }
  }
}

```

## 5.4.2 Rate matching for LDPC code 
- The bit sequence after encoding $d_0, d_1, d_2, ..., d_{N-1}$ from Clause 5.3.2 is written into a circular buffer of length $N_{cb}$ for the $r$ -th coded block, where $N$ is defined in Clause 5.3.2.

- Determination of $N_{cb}$
- Let:

$$
N_{cb} =
\begin{cases}
N & \text{if } I_{LBRM} = 0 \\
\min(N, N_{ref}) & \text{otherwise}
\end{cases}
$$

- Where:

$$
N_{ref} = \left\lfloor \frac{TBS_{LBRM}}{C \cdot R_{LBRM}} \right\rfloor
$$

- $R_{LBRM} = \frac{2}{3}$

**nr_rate_matching.c**
```
//Bit selection
  uint32_t N = (BG == 1) ? (66 * Z) : (50 * Z);
  uint32_t Ncb;
  if (Tbslbrm == 0)
    Ncb = N;
  else {
    uint32_t Nref = 3 * Tbslbrm / (2 * C); //R_LBRM = 2/3
    Ncb = min(N, Nref);
  }
```

- DL-SCH with PDSCH (DCI format 4_0/4_1/4_2)

<img width="696" height="362" alt="image" src="https://github.com/user-attachments/assets/f3cab7a1-4810-4588-a76d-d33b0b7b1ae5" />

- UL-SCH (DCI format 4_0/4_1/4_2)

<img width="708" height="301" alt="image" src="https://github.com/user-attachments/assets/afa87f3d-580e-4119-9942-794f8ea0d62b" />

- Maximum number of layers for one TB of DL-SCH/PCH:
  - min(X ,4),where:
    - If maxMIMO-Layers of PDSCH-ServingCellConfig is configured → X= that value
    - Else → X = max number of PDSCH layers supported by the UE

- DL-SCH Modulation Order (Qm):

<img width="703" height="184" alt="image" src="https://github.com/user-attachments/assets/2d2b8626-8f4f-4f84-a146-87e84b0bc5c2" />

<img width="703" height="578" alt="image" src="https://github.com/user-attachments/assets/a2359499-377f-4ff5-808b-95089bcab6a4" />

```
  if (Foffset > E) {
    LOG_E(PHY,
          "nr_rate_matching: invalid parameters (Foffset %d > E %d) F %d, k0 %d, Ncb %d, rvidx %d, Tbslbrm %d\n",
          Foffset,
          E,
          F,
          ind,
          Ncb,
          rvidx,
          Tbslbrm);
    return -1;
  }
  if (Foffset > Ncb) {
    LOG_E(PHY, "nr_rate_matching: invalid parameters (Foffset %d > Ncb %d)\n", Foffset, Ncb);
    return -1;
  }

  if (ind >= Foffset && ind < (F + Foffset))
    ind = F + Foffset;

  uint32_t k = 0;
  if (ind < Foffset) { // case where we have some bits before the filler and the rest after
    memcpy((void *)e, (void *)(d + ind), Foffset - ind);

    if (E + F <= Ncb - ind) { // E+F doesn't contain all coded bits
      memcpy((void *)(e + Foffset - ind), (void *)(d + Foffset + F), E - Foffset + ind);
      k = E;
    } else {
      memcpy((void *)(e + Foffset - ind), (void *)(d + Foffset + F), Ncb - Foffset - F);
      k = Ncb - F - ind;
    }
  } else {
    if (E <= Ncb - ind) { // E+F doesn't contain all coded bits
      memcpy((void *)(e), (void *)(d + ind), E);
      k = E;
    } else {
      memcpy((void *)(e), (void *)(d + ind), Ncb - ind);
      k = Ncb - ind;
    }
  }

  while (k < E) { // case where we do repetitions (low mcs)
    for (ind = 0; (ind < Ncb) && (k < E); ind++) {
#ifdef RM_DEBUG
      printf("RM_TX k%u Ind: %u (%d)\n", k, ind, d[ind]);
#endif

      if (ind == Foffset)
        ind = F + Foffset; // skip filler bits

      e[k++] = d[ind];

    }
  }

  return 0;
}
```

## 5.4.2.2 Bit interleaving 
**nr_rate_matching/nr_interleaving_ldpc**

## 5.5 Code block concatenation 
**nrLDPC_coding_segment_encoder.c/write_tast_output()**

<img width="741" height="322" alt="image" src="https://github.com/user-attachments/assets/b2683850-bdcc-4877-92dd-55b70c6f16db" />

```
for (int i=0;i<E2;i+=16) {
    uint32_t Eoffset2 = Eoffset;
    if (i<E) {	
      for (int j=0; j < E2_first_segment; j++) {
        uint32_t Eoffset2_byte = Eoffset2 >> 4;
        uint32_t Eoffset2_bit = Eoffset2 & 15;
        uint8x16_t cshift = vandq_u8(vshlq_u8(((uint8x16_t*)f)[i >> 4],vshift[j]),vmask);
        int32_t tmp = (int)vaddv_u8(vget_low_u8(cshift));
        tmp += (int)(vaddv_u8(vget_high_u8(cshift))<<8);
        *(output_p + Eoffset2_byte)   |= (uint16_t)(tmp<<Eoffset2_bit);
        *(output_p + Eoffset2_byte+1) |= (uint16_t)(tmp>>(16-Eoffset2_bit));
        Eoffset2 += E;
      }
    } else {
      for (int j=0; j < E2_first_segment; j++) {
        Eoffset2 += E;
      }
    }
    for (int j=E2_first_segment; j < nb_segments; j++) {
      uint32_t Eoffset2_byte = Eoffset2 >> 4;
      uint32_t Eoffset2_bit = Eoffset2 & 15;
      uint8x16_t cshift = vandq_u8(vshlq_u8(((uint8x16_t*)f2)[i >> 4],vshift[j]),vmask);
      int32_t tmp = (int)vaddv_u8(vget_low_u8(cshift));
      tmp += (int)(vaddv_u8(vget_high_u8(cshift))<<8);
      *(output_p + Eoffset2_byte)   |= (uint16_t)(tmp<<Eoffset2_bit);
      *(output_p + Eoffset2_byte+1) |= (uint16_t)(tmp>>(16-Eoffset2_bit));
      Eoffset2 += E2;
    }
    output_p++;
  }
```

# 7. Downlink transport channels and control information
## 7.1 Broadcast channel 

### 7.1.1 PBCH payload generation 
**nr_pbch.c**

<img width="863" height="100" alt="image" src="https://github.com/user-attachments/assets/ad7f5e58-f926-4c72-b538-3a2ecaf379f8" />

```
const uint8_t *pbch_pdu = (const uint8_t*)&ssb_pdu->ssb_pdu_rel15.bchPayload;
uint32_t pbch_a = 0;
for (int i = 0; i < NR_PBCH_PDU_BITS; i++)
  pbch_a |= ((pbch_pdu[i >> 3] >> (7 - (i & 7))) & 1) << i;
//Extracts the PBCH payload from bchPayload (24 bits).
//Converts it bit-by-bit into a 32-bit variable pbch_a
```
- <img width="683" height="41" alt="image" src="https://github.com/user-attachments/assets/d63b0417-ec18-45aa-8dc8-901b658e085c" />

```
 uint32_t extra_byte = nr_pbch_extra_byte_generation(sfn, n_hf, ssb_index, ssb_sc_offset, Lmax);
  pbch_a |= extra_byte << 24;


uint32_t nr_pbch_extra_byte_generation(int sfn, int n_hf, int ssb_index, int ssb_sc_offset, int Lmax)
{
  uint32_t extra_byte = 0;
  // Extra byte generation
  for (int i = 0; i < 4; i++)
    extra_byte |= ((sfn >> (3 - i)) & 1) << i; // resp. 4th, 3rd, 2nd ans 1st lsb of sfn

  extra_byte |= n_hf << 4; // half frame index bit

  if (Lmax == 64)
    for (int i = 0; i < 3; i++)
      extra_byte |= (uint32_t)((ssb_index >> (5 - i)) & 1) << (5 + i); // resp. 6th, 5th and 4th bits of ssb_index
  else
    extra_byte |= ((ssb_sc_offset >> 4) & 1) << 5; //MSB of k_SSB (bit index 4)
  return extra_byte;
}
| Field              | Source parameter  | Description                                                  | Bit Index (āA+X) |
| ------------------ | ----------------- | ------------------------------------------------------------ | ----------------- |
| `āA+0` \~ `āA+3` | `sfn`             | 4 LSBs of system frame number (SFN): 4th, 3rd, 2nd, 1st bits | 0–3               |
| `āA+4`            | `n_hf`            | Half-frame index bit (0 or 1)                                | 4                 |
| `āA+5~7`          | depends on `Lmax` | If `Lmax = 64`, 6th, 5th, 4th bits of `ssb_index`            | 5–7               |
|                    |                   | If `Lmax < 64`, bit 4 of `k_SSB = ssb_sc_offset` used        | 5 only            |

```

**Payload Interleaving**
```
// Payload interleaving
  uint32_t pbch_a_interleaved = 0;
  uint8_t *interleaver = gNB->nr_pbch_interleaver;
  for (int i = 0; i < NR_POLAR_PBCH_PAYLOAD_BITS; i++) {
    pbch_a_interleaved |= ((pbch_a >> i) & 1) << (*(interleaver + i));
//The 32-bit pbch_a is interleaved using a predefined index table interleaver
```

### 7.1.2 Scrambling
**nr_pbch_scrambling()**
```
// Scrambling
  uint32_t unscrambling_mask = (Lmax == 64) ? 0x100006D : 0x1000041;
  uint16_t M = (Lmax == 64)? (NR_POLAR_PBCH_PAYLOAD_BITS - 6) : (NR_POLAR_PBCH_PAYLOAD_BITS - 3);
  uint8_t nushift = (((sfn >> 2) & 1) << 1) ^ ((sfn >> 1) & 1);
  uint32_t pbch_a_prime = nr_pbch_scrambling(pbch_a_interleaved,
                                             (uint32_t)config->cell_config.phy_cell_id.value,
                                             nushift,
                                             M,
                                             NR_POLAR_PBCH_PAYLOAD_BITS,
                                             unscrambling_mask);

```

### 7.1.3 Transport block CRC attachment
### 7.1.4 Channel coding
### 7.1.5 Rate matching
**polar_encoder_fast()** 
-  Step 1: Get Polar Parameters
-  Step 2: CRC Attachment
-  Step 3: Combine Payload + CRC into B[]
-  Step 4: Interleaving → C′
-  Step 5: Bit Insertion → u[]
-  Step 6: Polar Transform → u × G
-  Step 7: Rate Matching

##  7.2 Downlink shared channel and paging channel
### 7.2.1 Transport block CRC attachment 
- Error detection is provided on each transport block using a Cyclic Redundancy Check (CRC).
- Bits in a transport block delivered to layer 1:a₀, a₁, a₂, ..., a_(A−1)
- where `A` is the payload size.
- CRC parity bits:p₀, p₁, ..., p_(L−1)

where `L` is the number of parity bits.

- The lowest order information bit `a₀` is mapped to the MSB of the block (see TS 38.321 Clause 6.1.1).

- CRC size and generator polynomial:
- If `A > 3824`:  
  Set `L = 24` and use generator polynomial `g_CRC24A(D)`
- Else:  
  Set `L = 16` and use generator polynomial `g_CRC16(D)`

- The resulting output sequence is:b₀, b₁, ..., b_(B−1), where B = A + L

//nr_dlsch_coding.c
```
if (A > NR_MAX_PDSCH_TBS) {
      // Add 24-bit crc (polynomial A) to payload
      crc = crc24a(a, A) >> 8;
      a[A >> 3] = ((uint8_t *)&crc)[2];
      a[1 + (A >> 3)] = ((uint8_t *)&crc)[1];
      a[2 + (A >> 3)] = ((uint8_t *)&crc)[0];
      // printf("CRC %x (A %d)\n",crc,A);
      // printf("a0 %d a1 %d a2 %d\n", a[A>>3], a[1+(A>>3)], a[2+(A>>3)]);
      B = A + 24;
      //    harq->b = a;
      AssertFatal((A / 8) + 4 <= max_bytes, "A %d is too big (A/8+4 = %d > %d)\n", A, (A / 8) + 4, max_bytes);
      memcpy(harq->b, a, (A / 8) + 4); // why is this +4 if the CRC is only 3 bytes?
    } else {
      // Add 16-bit crc (polynomial A) to payload
      crc = crc16(a, A) >> 16;
      a[A >> 3] = ((uint8_t *)&crc)[1];
      a[1 + (A >> 3)] = ((uint8_t *)&crc)[0];
      // printf("CRC %x (A %d)\n",crc,A);
      // printf("a0 %d a1 %d \n", a[A>>3], a[1+(A>>3)]);
      B = A + 16;
      //    harq->b = a;
      AssertFatal((A / 8) + 3 <= max_bytes, "A %d is too big (A/8+3 = %d > %d)\n", A, (A / 8) + 3, max_bytes);
      memcpy(harq->b, a, (A / 8) + 3); // using 3 bytes to mimic the case of 24 bit crc
    }
```

### 7.2.2 LDPC Base Graph Selection

For the initial transmission of a transport block with coding rate `R` (as determined by the MCS index per Clause 5.1.3.1 in TS 38.214), and also for retransmissions:

Each code block of the transport block shall be encoded using **LDPC Base Graph 1** or **Base Graph 2** based on the following conditions:

- Use **Base Graph 2** if:
  - `A ≤ 292`, or  
  - `A ≤ 3824` and `R ≤ 0.67`, or  
  - `R ≤ 0.25`

- Otherwise, use **Base Graph 1**

Where:
- `A` is the payload size as defined in Clause 7.2.1.
- `R` is the code rate.

### 7.2.3 Code Block Segmentation and Code Block CRC Attachment
//**nr_segmentation.c**
The input bit sequence to the code block segmentation is:
- `b_0, b_1, b_2, ..., b_{B-1}`
- `B` is the number of bits in the transport block (including CRC).

The segmentation and CRC attachment for code blocks are performed according to Clause 5.2.2.

After segmentation and CRC attachment, the resulting code blocks are denoted as:
- `c_{r,0}, c_{r,1}, c_{r,2}, ..., c_{r,K_r-1}`
- `r` is the code block index.
- `K_r` is the number of bits in code block `r`, as defined in Clause 5.2.2.

### 7.2.4 Channel Coding
**ldpc_encoder.c called by ldpc8blocks() in nrLDPC_coding_segment_encoder.c**
- Code blocks are passed to the channel coding unit.
- The bits in each code block are denoted by:
  `c_{r,0}, c_{r,1}, c_{r,2}, ..., c_{r,K_r-1}`
  where:
  - `r` is the code block index.
  - `K_r` is the number of bits in code block `r`.

- The total number of code blocks is denoted by `C`.

- Each code block is LDPC encoded individually according to Clause 5.3.2.

- After LDPC encoding, the output bits are denoted by:
  `d_{r,0}, d_{r,1}, d_{r,2}, ..., d_{r,N_r-1}`
  where `N_r` is the number of encoded bits for code block `r`, as defined in Clause 5.3.2.

### 7.2.5 Rate Matching
**nr_rate_matching.c called by ldpc8blocks() in nrLDPC_coding_segment_encoder.c**
- Coded bits from each code block are denoted by:
  `d_{r,0}, d_{r,1}, d_{r,2}, ..., d_{r,N_r-1}`

  where:
  - `r` is the code block number.
  - `N_r` is the number of encoded bits for code block `r`.

- These bits are input to the rate matching block.

- The total number of code blocks is denoted by `C`.

- Each code block is rate matched individually according to Clause 5.4.2 by setting `I_{LBRM} = 1`.

- After rate matching, the output bits are denoted by:
  `f_{r,0}, f_{r,1}, f_{r,2}, ..., f_{r,E_r-1}`
  where `E_r` is the number of rate matched bits for code block `r`.

### 7.2.6 Code Block Concatenation
**write_task_output() in nrLDPC_coding_segment_encoder.c**
- The input bit sequences to the concatenation block are:
  `f_{r,0}, f_{r,1}, f_{r,2}, ..., f_{r,E_r-1}` for `r = 0, ..., C-1`.

  where:
  - `E_r` is the number of rate matched bits for the `r`-th code block.
  - `C` is the total number of code blocks.

- Code block concatenation is performed according to Clause 5.5.

- The output bit sequence after concatenation is:
  `g_0, g_1, g_2, ..., g_{G-1}`

  where:
  - `G` is the total number of coded bits for transmission.

