**References:TS 138 211,TS 138 201 and TS 138 30**
**OAI folder NR_REFSIG,NR_TRANSPORT,MODULATION**

<img width="1121" height="530" alt="image" src="https://github.com/user-attachments/assets/84461b2d-ab9f-457b-a075-272ed7f50c2b" />

# 4 Frame structure and physical resources 

## 4.1 General 
**Time Domain Unit Definitions**
- Base time unit ùëáùëê is derived from the maximum subcarrier spacing and FFT size:

<img width="582" height="213" alt="image" src="https://github.com/user-attachments/assets/38225ce7-6d68-4e10-925b-e43e0612bcc3" />

- Reference time unit ùëáùë† is used for timing calculations based on a reference subcarrier spacing:

<img width="601" height="369" alt="image" src="https://github.com/user-attachments/assets/77a29fc1-e885-4aca-b416-43dbc4bd9c64" />

## 4.2 Numerologies

Multiple OFDM numerologies are supported as defined in **Table 4.2-1**, where:
- `Œº` is the numerology index
- Subcarrier spacing `Œîf` = 2^Œº √ó 15 kHz
- The cyclic prefix (CP) is determined by higher-layer parameter `cyclicPrefix`.

These values apply to both uplink and downlink bandwidth parts, configured via `subcarrierSpacing` and `cyclicPrefix`.

##  Table 4.2-1: Supported Transmission Numerologies

| Œº | Œîf = 2^Œº¬∑15[kHz] | Cyclic Prefix        |
|---|------------------|----------------------|
| 0 | 15 kHz           | Normal               |
| 1 | 30 kHz           | Normal               |
| 2 | 60 kHz           | Normal, Extended     |
| 3 | 120 kHz          | Normal               |
| 4 | 240 kHz          | Normal               |
| 5 | 480 kHz          | Normal               |
| 6 | 960 kHz          | Normal               |

>  Extended CP is only available for Œº = 2.

---

### Notes

- Larger `Œº` ‚Üí Larger subcarrier spacing ‚Üí Lower symbol duration ‚Üí Suitable for low-latency or high-frequency bands (e.g., mmWave).
- `Œº = 0` and `Œº = 1` are typically used for FR1 (Sub-6GHz).
- `Œº ‚â• 2` are used for FR2 and specific services like URLLC.


## 4.3 Frame structure
**Frames and subframes**
- Downlink, uplink, and sidelink transmissions are organized into radio frames.
- Each radio frame has a duration of 10 ms, denoted as:
- <img width="336" height="77" alt="image" src="https://github.com/user-attachments/assets/9e69c772-dc92-40b6-b5bf-f2a4b04d1994" />

- Each frame consists of 10 subframes, and each subframe has:
- <img width="336" height="77" alt="image" src="https://github.com/user-attachments/assets/c984f9d1-4fb6-4845-9201-2d8ccaa0255c" />

- The number of consecutive OFDM symbols per subframe depends on:
- <img width="314" height="49" alt="image" src="https://github.com/user-attachments/assets/a3c14cf9-395e-499e-80ec-37a89d59f5dc" />

- Each frame is divided into two half-frames:
  - Half-frame 0: Subframes 0‚Äì4
  - Half-frame 1: Subframes 5‚Äì9
There is one set of frames for uplink and one for downlink on a carrier.

**Uplink Frame Timing (with respect to DL)**
- Uplink frame ùëñ begins at time:
- <img width="700" height="379" alt="image" src="https://github.com/user-attachments/assets/9a90a267-692d-4e45-a49f-44acd5192627" />

- <img width="397" height="165" alt="image" src="https://github.com/user-attachments/assets/c57b1c6f-c2e1-4d34-b85a-6c57f069d223" />

- This figure shows that uplink frame ùëñ starts slightly after the start of downlink frame ùëñ by an amount 
ùëáta


**Slots**
## Slot Indexing

For subcarrier spacing configuration `Œº`, slots are numbered as:

- Within a subframe:

 <img width="178" height="33" alt="image" src="https://github.com/user-attachments/assets/64d6194d-a059-4fd4-8d4e-51428d67271a" />

- Within a frame:

<img width="161" height="32" alt="image" src="https://github.com/user-attachments/assets/c6368d30-f281-4973-bef6-cd59424f4a1a" />


Each slot consists of `N_symb^slot` OFDM symbols, where the number of symbols depends on the **cyclic prefix** (see Tables 4.3.2-1 and 4.3.2-2).

Slot start is aligned with the **first OFDM symbol** of a subframe.

---

## Slot Type

Each slot may contain symbols classified as:
- **Downlink**
- **Uplink**
- **Flexible**

> The structure of slot formats is defined in TS 38.213, clause 11.1.

- In a **downlink frame**, UE must only transmit in `downlink` or `flexible` symbols.
- In an **uplink frame**, UE must only transmit in `uplink` or `flexible` symbols.

---

## Half/Full Duplex and Transition Constraints

UEs **not supporting full-duplex or simultaneous Tx/Rx** across cells must respect **guard times** between:
- Last DL symbol and next UL slot ‚Üí wait `N_RX‚ÜíTX √ó Tc`
- Last UL symbol and next DL slot ‚Üí wait `N_TX‚ÜíRX √ó Tc`

These timing gaps apply:
- Within a cell
- Across cells in inter-band CA, ENDC, or DAPS handover

See Table 4.3.2-3 for values.

---

##  Table 4.3.2-1: Normal Cyclic Prefix (N_CP)

| Œº | N<sup>slot</sup><sub>symb</sub> | N<sup>frame,Œº</sup><sub>slot</sub> | N<sup>subframe,Œº</sup><sub>slot</sub> |
|---|--------------------------|-----------------------------|-------------------------------|
| 0 | 14                       | 10                          | 1                             |
| 1 | 14                       | 20                          | 2                             |
| 2 | 14                       | 40                          | 4                             |
| 3 | 14                       | 80                          | 8                             |
| 4 | 14                       | 160                         | 16                            |
| 5 | 14                       | 320                         | 32                            |
| 6 | 14                       | 640                         | 64                            |

---

##  Table 4.3.2-2: Extended Cyclic Prefix (E_CP, only Œº = 2)

| Œº | N<sup>slot</sup><sub>symb</sub> | N<sup>frame,Œº</sup><sub>slot</sub> | N<sup>subframe,Œº</sup><sub>slot</sub> |
|---|--------------------------|-----------------------------|-------------------------------|
| 2 | 12                       | 40                          | 4                             |

---

##  Table 4.3.2-3: Transition Time (in Tc units)

| Transition Time   | FR1    | FR2    |
|-------------------|--------|--------|
| N<sub>Tx‚ÜíRx</sub> | 25600  | 13792  |
| N<sub>Rx‚ÜíTx</sub> | 25600  | 13792  |

## 4.4 Physical resources

**Antenna Ports**

An **antenna port** is defined such that the channel over which a symbol is transmitted on the port can be inferred from another symbol on the same port.

In other words:  
> If the channel characteristics remain the same for all symbols sent through the same antenna port, they are said to share the same antenna port.

---

**Quasi Co-Located (QCL) Antenna Ports**

Two antenna ports are said to be **quasi co-located** (QCL) if the large-scale channel properties from one port can be inferred from the other.

Large-scale properties include:
- Delay spread
- Doppler spread
- Doppler shift
- Average gain
- Average delay
- Spatial Rx parameters

>  QCL is essential in beamforming and channel estimation. When ports are QCL, UE can reduce overhead in measurements.

---

**4.4.2 Resource Grid**

For each numerology and carrier, a resource grid is defined by:

- `N_grid_k^size,Œº`: Number of subcarriers
- `N_sc^RB`: Number of subcarriers per Resource Block (RB)
- `N_symb^subframe,Œº`: Number of OFDM symbols per subframe

The grid starts from a common resource block index `N_grid^start,Œº`, as configured by higher-layer signaling.

There is **one resource grid per transmission direction**:
- DL: Downlink
- UL: Uplink
- SL: Sidelink

There is **one resource grid per antenna port**, per numerology Œº and per direction.

---

**Carrier Bandwidth and Starting Position**

- Carrier bandwidth `N_grid^size,Œº` for each Œº is set by `carrierBandwidth` in the `SCS-SpecificCarrier` IE.
- Grid starting index `N_grid^start,Œº` is set by `offsetToCarrier` in `SCS-SpecificCarrier`.

---

**Frequency Location**

Each subcarrier‚Äôs frequency location refers to the **center frequency** of the subcarrier.

---

**DC Subcarrier**

- **Downlink**: `txDirectCurrentLocation` (in `SCS-SpecificCarrier`) defines the DC subcarrier index.
  - Values:  
    - 0‚Äì3299: subcarrier index  
    - 3300: DC subcarrier is **outside** the grid

- **Uplink**: `txDirectCurrentLocation` (in `UplinkTxDirectCurrentBWP`) defines the DC subcarrier index.
  - DC is offset by 7.5 kHz from center  
  - Values:  
    - 0‚Äì3299: index  
    - 3300: outside grid  
    - 3301: undetermined

**4.4.3 Resource Elements**

Each element in the resource grid for antenna port *p* and subcarrier spacing configuration *Œº* is called a **resource element**.

It is uniquely identified by:

- $(k, l)_{p,Œº}$
  - *k*: index in the frequency domain
  - *l*: symbol position in the time domain (relative to a reference point)

The resource element $(k, l)_{p,Œº}$ corresponds to:
- A **physical resource**
- The **complex value** $a_{k,l}^{(p,Œº)}$

When there is no ambiguity, the indices *p* and *Œº* may be dropped:
- $a_{k,l}^{(p)}$
- or simply $a_{k,l}$

**4.4.4 Resource Blocks**

**4.4.4.1 General**
A Resource Block (RB) is defined as:
- `N_sc^RB = 12` consecutive subcarriers in the frequency domain.

---

**4.4.4.2 Point A**

Point A serves as a **common reference point** for RB grids, and is obtained from:

- `offsetToPointA`:
  - Represents the frequency offset from point A to the lowest subcarrier of the lowest resource block.
  - Expressed in units of RBs (15 kHz spacing for FR1, 60 kHz spacing for FR2 and FR2-NTN).
  - Used for initial cell selection via SS/PBCH.

- For operation **without shared spectrum channel access**:
  - In FR1, FR2-1, and FR2-NTN: the lowest RB uses the spacing from `subCarrierSpacingCommon`.

- For operation **with shared spectrum access**:
  - In FR1 or FR2, or FR2 without shared access: lowest RB aligns with SS/PBCH block used in cell selection.

- `absoluteFrequencyPointA`: used when expressed as ARFCN (absolute RF channel number).

---

**4.4.4.3 Common Resource Blocks**

- Common RBs are numbered from `0` upwards in frequency for subcarrier spacing `Œº`.
- The **center of subcarrier 0** of **common RB 0** for numerology `Œº` is aligned with **Point A**.

- The formula for RB index:
  
$$
n_{\text{CRB}}^{\mu} = \left\lfloor \frac{k}{N_{\text{sc}}^{\text{RB}}} \right\rfloor
$$

Where:
- *k* is the subcarrier index **relative to Point A**, with `k = 0` at the subcarrier centered at Point A.

**4.4.4.4 Physical Resource Blocks**

- Physical RBs are defined per subcarrier spacing Œº and within each bandwidth part (BWP).
- Indexed from 0 to $N_{BWP,i}^{size,Œº}$ - 1, where *i* is the BWP index.
- The mapping to common resource block (CRB) is:

$$
n_{\text{CRB}}^{\mu} = n_{\text{PRB}}^{\mu} + N_{\text{BWP},i}^{\text{start},\mu}
$$


- $N_{BWP,i}^{start,Œº}$: The CRB index where the BWP *i* starts.
- When Œº is clear from context, it may be omitted.

---

**4.4.4.5 Virtual Resource Blocks**

- VRBs are also defined within each BWP.
- Indexed from 0 to `N_BWP,i^size - 1`.

---

**4.4.4.6 Interlaced Resource Blocks**

- Multiple interlaces *m* ‚àà {0, 1, ..., M-1} are supported.
- Each interlace contains CRBs at offsets like `{m, M + m, 2M + m, ...}`.
- M depends on numerology Œº and is given by:

| Œº | M  |
|---|----|
| 0 | 10 |
| 1 | 5  |

- Mapping from interlace RBs to CRBs:

$$
n_{\text{CRB}}^{\mu} = M \cdot n_{\text{IRB},m}^{\mu} + N_{\text{BWP},i}^{\text{start},\mu} + \left( (m - N_{\text{BWP},i}^{\text{start},\mu}) \bmod M \right)
$$

- `n_IRB,m^Œº`: Interlace RB index *n* in interlace *m*.
- The UE expects at least 10 CRBs in any interlace within a BWP.

# 5 Generic functions 
## 5.2 Sequence generation
- The Gold sequence production is as follows:
  - Output sequence:
  - <img width="412" height="54" alt="image" src="https://github.com/user-attachments/assets/d56dd014-3de0-44d6-bf6a-615d00ae6c18" />
  - c(n) is out sequence
  - x1,x2 are two independent m-sequences
  - Nc = 1600 :Corresponding system delay alignment offset
 
- How to generate m-sequence:

<img width="650" height="70" alt="image" src="https://github.com/user-attachments/assets/bbf48c9b-3347-4bff-8d15-e4f64a10c9eb" />

| Sequence | Initialization Condition                                                           |
| -------- | ---------------------------------------------------------------------------------- |
| $x_1$    | Fixed: $x_1(0) = 1$, $x_1(1 \dots 30) = 0$                                         |
| $x_2$    | Initialized using a 31-bit integer $c_{\text{init}}$, depending on the application |

<img width="245" height="119" alt="image" src="https://github.com/user-attachments/assets/0d949ba9-c4d0-4ebf-8126-b171293427ea" />

```PHY/LTE_TRANSPORT/transport_proto.h
static inline  uint32_t lte_gold_generic(uint32_t *x1, uint32_t *x2, uint8_t reset)
{
  int32_t n;

  // 3GPP 3x.211
  // Nc = 1600
  // c(n)     = [x1(n+Nc) + x2(n+Nc)]mod2
  // x1(n+31) = [x1(n+3)                     + x1(n)]mod2
  // x2(n+31) = [x2(n+3) + x2(n+2) + x2(n+1) + x2(n)]mod2
  if (reset)
  {
      // Init value for x1: x1(0) = 1, x1(n) = 0, n=1,2,...,30
      // x1(31) = [x1(3) + x1(0)]mod2 = 1
      *x1 = 1 + (1U<<31);
      // Init value for x2: cinit = sum_{i=0}^30 x2*2^i
      // x2(31) = [x2(3)    + x2(2)    + x2(1)    + x2(0)]mod2
      //        =  (*x2>>3) ^ (*x2>>2) + (*x2>>1) + *x2
      *x2 = *x2 ^ ((*x2 ^ (*x2>>1) ^ (*x2>>2) ^ (*x2>>3))<<31);

      // x1 and x2 contain bits n = 0,1,...,31

      // Nc = 1600 bits are skipped at the beginning
      // i.e., 1600 / 32 = 50 32bit words

      for (n = 1; n < 50; n++)
      {
          // Compute x1(0),...,x1(27)
          *x1 = (*x1>>1) ^ (*x1>>4);
          // Compute x1(28),..,x1(31) and xor
          *x1 = *x1 ^ (*x1<<31) ^ (*x1<<28);
          // Compute x2(0),...,x2(27)
          *x2 = (*x2>>1) ^ (*x2>>2) ^ (*x2>>3) ^ (*x2>>4);
          // Compute x2(28),..,x2(31) and xor
          *x2 = *x2 ^ (*x2<<31) ^ (*x2<<30) ^ (*x2<<29) ^ (*x2<<28);
      }
  }

  *x1 = (*x1>>1) ^ (*x1>>4);
  *x1 = *x1 ^ (*x1<<31) ^ (*x1<<28);
  *x2 = (*x2>>1) ^ (*x2>>2) ^ (*x2>>3) ^ (*x2>>4);
  *x2 = *x2 ^ (*x2<<31) ^ (*x2<<30) ^ (*x2<<29) ^ (*x2<<28);

  // c(n) = [x1(n+Nc) + x2(n+Nc)]mod2
  return(*x1^*x2);
}
```
## 5.2.2 Low-PAPR sequence generation type 1 
- Low-PAPR Sequence Generation Type 1

<img width="773" height="290" alt="image" src="https://github.com/user-attachments/assets/b7a5b60e-d0a3-4a72-8490-d01e6427e34e" />

<img width="591" height="176" alt="image" src="https://github.com/user-attachments/assets/45ab3339-4ec5-4bb2-b1ac-267edb32d5ae" />

<img width="591" height="266" alt="image" src="https://github.com/user-attachments/assets/176a8b6d-fe94-4f70-b0fe-fb0faa253388" />

- This type of sequence is mainly used in Uplink DFT-s-OFDM (i.e., SC-FDMA) for DMRS. Specifically:
  - When UE sets transform_precoding = enabled in PUSCH

| Term                           | Meaning                                  |
| ------------------------------ | ---------------------------------------- |
| $\bar{r}_{u,v}(n)$             | Base sequence                            |
| $r_{u,v}^{(\alpha,\delta)}(n)$ | Low-PAPR sequence with phase rotation    |
| $u$                            | Group index (0 to 29)                    |
| $v$                            | Base sequence index (0 or 1)             |
| $M_{ZC}$                       | ZC sequence length, depends on bandwidth |

**Base Sequences of Length 36 or Larger**

<img width="676" height="194" alt="image" src="https://github.com/user-attachments/assets/dfe92c92-490f-4be8-9b8b-cb56b1a3f2ce" />

<img width="684" height="227" alt="image" src="https://github.com/user-attachments/assets/993c592f-5eb8-4a15-8865-da5661067cb1" />

**Base Sequences of Length Less Than 36**

<img width="763" height="534" alt="image" src="https://github.com/user-attachments/assets/ad96bf6a-6975-45b3-8567-42f109fa0c8d" />

## 5.2.3  Low-PAPR sequence generation type 2 

<img width="752" height="186" alt="image" src="https://github.com/user-attachments/assets/46d815c1-2f9c-409f-84dc-4a88b5680ece" />

<img width="685" height="198" alt="image" src="https://github.com/user-attachments/assets/9a2c1b16-7e77-4c53-91a6-ae2e46f19640" />

-  Base Sequence Construction:
<img width="722" height="253" alt="image" src="https://github.com/user-attachments/assets/4b41751c-5d53-40a0-8a70-4341b29bae0d" />

- 5.2.3.1 Sequences of length 30 or larger

<img width="737" height="123" alt="image" src="https://github.com/user-attachments/assets/cd609b76-43a2-4398-aeaa-da4d8143a590" />

- 5.2.3.2 Sequences of length less than 30

<img width="739" height="251" alt="image" src="https://github.com/user-attachments/assets/f495a169-f39b-40b6-a912-3c08a98fd1d9" />


**Difference Between Low-PAPR Sequence Type 1 and Type 2**

| Item                       | Type 1                                                                                      | Type 2                                                                 |
| -------------------------- | ------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------- |
|  Main Usage              | DFT-s-OFDM uplink (SC-FDMA)<br>Commonly used for PUSCH                                      | DFT-s-OFDM uplink (less common)                                        |
|  Reference Section       | TS 38.211 ¬ß5.2.2                                                                            | TS 38.211 ¬ß5.2.3                                                       |
|  Sequence Basis          | Based on Zadoff-Chu (ZC) base sequences with cyclic shift                                   | Sequences are defined in the frequency domain via DFT of ZC            |
|  PAPR Reduction Method   | Uses low-correlation and constant envelope properties of ZC                                 | Uses predefined sequences in the frequency domain to maintain low PAPR |
|  Parameters Used         | `u` (group index)<br>`v` (base sequence index)<br>`Œ±` (cyclic shift)<br>`Œ¥` (low PAPR type) | `u`, `v`, and different formulas depending on sequence length          |
|  Typical Sequence Length | $M_{ZC} \geq 36$; if $M_{ZC} < 36$, use lookup tables                                       | Only supports $M < 30$, such as 6, 12, 18, 24                          |
|  Implementation          | Constructed from $\tilde{r}_{u,v}(n)$, then cyclically shifted by Œ±                         | Uses predefined œÜ(n) tables and frequency-domain manipulation          |


## 5.3.1 OFDM baseband signal generation for all channels except PRACH


**Time Domain Definition**

This formula defines the time-domain baseband signal <img width="75" height="43" alt="image" src="https://github.com/user-attachments/assets/0dec78aa-f5f4-4af5-8446-9556cb0e6cc8" /> for OFDM symbol 
ùëô on antenna port ùëù and subcarrier spacing configuration ùúá, valid for any physical channel or signal except PRACH and RIM-RS.

**Time Interval of the OFDM Symbol**

<img width="658" height="165" alt="image" src="https://github.com/user-attachments/assets/5c8c837e-72b5-4798-9e58-f55a65a913c3" />

**Expression of the OFDM Signal in Time Domain**

<img width="658" height="384" alt="image" src="https://github.com/user-attachments/assets/5290d4f6-ca79-4c89-acec-6394169eee18" />

**Frequency Offset for Centering Subcarriers**

<img width="658" height="169" alt="image" src="https://github.com/user-attachments/assets/81a25a32-7ae6-4261-8a79-8ff7ead99be0" />

OFDM Symbol Duration (including CP)

<img width="658" height="232" alt="image" src="https://github.com/user-attachments/assets/80faabbe-18b4-4537-a299-c1241efa2b98" />

**Cyclic Prefix Length**

<img width="726" height="263" alt="image" src="https://github.com/user-attachments/assets/92eb0b85-c648-410f-9a61-d4056246ef78" />

**Additional Notes**

<img width="734" height="175" alt="image" src="https://github.com/user-attachments/assets/41b8cf7c-57d9-49b4-a7da-ccf01a0fb78b" />

** OFDM Symbol Start Time**

<img width="705" height="261" alt="image" src="https://github.com/user-attachments/assets/d0146351-f496-4a39-b7fa-52f46f0499f9" />

**CP Extension for Special Cases**

<img width="710" height="312" alt="image" src="https://github.com/user-attachments/assets/fc47689f-aa7c-47a5-a1dd-f003cd7e4409" />

**How to Calculate ùëáùëíùë•ùë°**

‚Äã<img width="710" height="475" alt="image" src="https://github.com/user-attachments/assets/32625e6c-c652-4a3a-8fc3-442d26929afc" />

<img width="710" height="207" alt="image" src="https://github.com/user-attachments/assets/851f252f-f892-410a-8a46-e05e14cdb77b" />

**For dynamically scheduled Uplink (PUSCH, SRS, PUCCH)**

| $i$ (index) | $C_i$ | $\Delta_i$                |
| ----------- | ----- | ------------------------- |
| 0           | ‚Äì     | ‚Äì                         |
| 1           | $C_1$ | $25\cdot10^{-6}$          |
| 2           | $C_2$ | $16\cdot10^{-6} + T_{TA}$ |
| 3           | $C_3$ | $25\cdot10^{-6} + T_{TA}$ |

<img width="762" height="195" alt="image" src="https://github.com/user-attachments/assets/4f7c4927-933f-4986-a30a-fb5dbd0affb5" />


**For PUSCH using Configured Grant**

| index $i$ | $\Delta_i$                                                            |
| --------- | --------------------------------------------------------------------- |
| 0         | $16\cdot10^{-6}$                                                      |
| 1         | $25\cdot10^{-6}$                                                      |
| 2         | $34\cdot10^{-6}$                                                      |
| 3         | $43\cdot10^{-6}$                                                      |
| 4         | $52\cdot10^{-6}$                                                      |
| 5         | $61\cdot10^{-6}$                                                      |
| 6         | $\displaystyle\sum_{k=1}^{2^\mu}T^{\mu}_{symb,(l-k)\bmod7\cdot2^\mu}$ |

<img width="762" height="150" alt="image" src="https://github.com/user-attachments/assets/280e5dfa-3d47-4087-b4ac-47fb80b0b55c" />

**For Sidelink CP Extension**

| `Index i` | $\mu = 0$              | $\mu = 1$              | $\mu = 2$              |
| --------- | ---------------------- | ---------------------- | ---------------------- |
|           | $C_i$ / $\Delta_i$     | $C_i$ / $\Delta_i$     | $C_i$ / $\Delta_i$     |
| 0         | ‚Äì / ‚Äì                  | ‚Äì / ‚Äì                  | ‚Äì / ‚Äì                  |
| 1         | 1 / $16 \cdot 10^{-6}$ | 1 / $16 \cdot 10^{-6}$ | 1 / $16 \cdot 10^{-6}$ |
| 2         | 1 / $25 \cdot 10^{-6}$ | 1 / $25 \cdot 10^{-6}$ | 2 / $25 \cdot 10^{-6}$ |
| 3         | 1 / $34 \cdot 10^{-6}$ | 2 / $16 \cdot 10^{-6}$ | 2 / $25 \cdot 10^{-6}$ |
| 4         | 1 / $43 \cdot 10^{-6}$ | 2 / $25 \cdot 10^{-6}$ | reserved               |
| 5         | 1 / $52 \cdot 10^{-6}$ | 2 / $34 \cdot 10^{-6}$ | reserved               |
| 6         | 1 / $61 \cdot 10^{-6}$ | 2 / $43 \cdot 10^{-6}$ | reserved               |
| 7         | reserved               | 2 / $52 \cdot 10^{-6}$ | reserved               |
| 8         | reserved               | 2 / $61 \cdot 10^{-6}$ | reserved               |

<img width="762" height="150" alt="image" src="https://github.com/user-attachments/assets/4f8dab89-a8a2-411d-9aa8-1fdbe7283233" />

# 6.3 Physical channels 
## Scrambling 
<img width="746" height="258" alt="image" src="https://github.com/user-attachments/assets/1a268383-af7a-40ed-a187-e626b7b012c8" />

<img width="476" height="227" alt="image" src="https://github.com/user-attachments/assets/10af38ae-cd60-4463-9273-c90f9294868c" />

<img width="683" height="149" alt="image" src="https://github.com/user-attachments/assets/34719906-cf4a-4baf-b186-a095649ad366" />

<img width="720" height="531" alt="image" src="https://github.com/user-attachments/assets/efc80f9b-4643-4dba-bcc7-273139aa656f" />

## Modulation

<img width="731" height="223" alt="image" src="https://github.com/user-attachments/assets/0e7bb65f-360e-4d0e-bfdb-13aa4aa14bd0" />

| **Transform precoding disabled** | **Modulation order** $Q_m$ | **Transform precoding enabled** | **Modulation order** $Q_m$ |
| -------------------------------- | -------------------------- | ------------------------------- | -------------------------- |
| QPSK                             | 2                          | œÄ/2-BPSK                        | 1                          |
| 16QAM                            | 4                          | QPSK                            | 2                          |
| 64QAM                            | 6                          | 16QAM                           | 4                          |
| 256QAM                           | 8                          | 64QAM                           | 6                          |
| ‚Äî                                | ‚Äî                          | 256QAM                          | 8                          |
## Layer mapping

<img width="701" height="350" alt="image" src="https://github.com/user-attachments/assets/fc421cbd-35bf-44b3-9d0d-f82123c59aa2" />

## Transform precoding(uplink and single-layer)

<img width="744" height="432" alt="image" src="https://github.com/user-attachments/assets/c5857605-eeb6-4229-9500-f4acf4482c6e" />

<img width="396" height="278" alt="image" src="https://github.com/user-attachments/assets/a25531c6-86a6-43cd-9e6b-8f24b8209642" />

<img width="725" height="479" alt="image" src="https://github.com/user-attachments/assets/adc08469-ec4a-4b01-8158-5b370998b67d" />

<img width="427" height="98" alt="image" src="https://github.com/user-attachments/assets/481da1f7-88e5-4fde-9478-64a35e58684b" />

## Precoding

<img width="665" height="429" alt="image" src="https://github.com/user-attachments/assets/3ccbf717-316d-4f42-a858-b0d7f54a9696" />

<img width="665" height="575" alt="image" src="https://github.com/user-attachments/assets/bb01d9f1-9579-4dda-b756-5b5e1abc087c" />

# 6.3.2 Physical uplink control channel 

<img width="743" height="306" alt="image" src="https://github.com/user-attachments/assets/5cb06db9-19c7-444a-9024-ad04c424a3ea" />

## Group and cyclic hopping 

<img width="730" height="492" alt="image" src="https://github.com/user-attachments/assets/f2906dc4-41b9-4a57-915b-3ac0d774747b" />

<img width="720" height="353" alt="image" src="https://github.com/user-attachments/assets/b6db9c32-bd7c-449f-8ae4-69526573863a" />

<img width="720" height="575" alt="image" src="https://github.com/user-attachments/assets/4ee1197c-2f1e-4572-a857-f1626cb578a8" />

## Cyclic shift hopping

<img width="737" height="600" alt="image" src="https://github.com/user-attachments/assets/80c45aeb-0bf3-42a2-9a7c-fa7780cbe299" />

<img width="737" height="286" alt="image" src="https://github.com/user-attachments/assets/97027eff-fd7c-4fce-a707-99368deae699" />


| Format | OFDM Symbol Length (\$N^{PUCCH}\_{symb}\$) | UCI Bits | Description                             |
| ------ | ------------------------------------------ | -------- | --------------------------------------- |
| **0**  | 1‚Äì2 symbols                                | ‚â§ 2 bits | Short format with single/double symbol  |
| **1**  | 4‚Äì14 symbols                               | ‚â§ 2 bits | Long format for small payloads          |
| **2**  | 1‚Äì2 symbols                                | > 2 bits | Short format for large UCI              |
| **3**  | 4‚Äì14 symbols                               | > 2 bits | Long format with sequence hopping       |
| **4**  | 4‚Äì14 symbols                               | > 2 bits | Long format with multiple antenna ports |


# 6.4 Physical signals 
## Sequence generation 
**Demodulation Reference Signal for PUSCH (No Transform Precoding)**

<img width="804" height="331" alt="image" src="https://github.com/user-attachments/assets/5171bef6-c7b5-4150-aecc-445270b536ea" />

<img width="804" height="388" alt="image" src="https://github.com/user-attachments/assets/855f4cff-1496-4d58-ab0c-9e46330fba7c" />

<img width="804" height="388" alt="image" src="https://github.com/user-attachments/assets/f6246397-7acb-4419-8593-1bdc0b40a995" />

**Sequence Generation When Transform Precoding is Enabled**

<img width="728" height="325" alt="image" src="https://github.com/user-attachments/assets/28533636-d6e5-4773-bcbd-8a5181bc66ed" />

<img width="728" height="529" alt="image" src="https://github.com/user-attachments/assets/653c664d-4157-4c60-becb-dc3ad7381e55" />

<img width="728" height="609" alt="image" src="https://github.com/user-attachments/assets/6ab4b16b-8452-446f-91d6-605dbd40e51f" />

<img width="728" height="166" alt="image" src="https://github.com/user-attachments/assets/69be1692-a56d-4552-a1ef-70973a91bfb3" />





# slot_fep_nr.c
## include
```
#include "PHY/defs_nr_UE.h"//UE definition
#include "PHY/defs_gNB.h"//gNB definition
#include "modulation_UE.h"//UE modulation_UE
#include "nr_modulation.h"//NR modulation_UE
#include "PHY/LTE_ESTIMATION/lte_estimation.h"
#include "PHY/NR_UE_ESTIMATION/nr_estimation.h"//NR channel estimationÔºàUEÔºâ
#include "PHY/nr_phy_common/inc/nr_phy_common.h"//common PHY tool
#include <common/utils/LOG/log.h>
```
## nr_slot_fep_ul 
```
int nr_slot_fep_ul(NR_DL_FRAME_PARMS *frame_parms, /PHY/defs_nr_common.h
                   int32_t *rxdata,/time domain data
                   int32_t *rxdataF,/frequence domain data
                   unsigned char symbol, symbol number of this slot
                   unsigned char Ns,
                   int sample_offset);
```
- nb_prefix_samples // Number of prefix samples in all but first symbol of slot
- nb_prefix_samples0 // Number of prefix samples in first symbol of slot

**dft_size_idx_t dftsize = get_dft(frame_parms->ofdm_symbol_size);**
- ofdm_symbol_size// Size of FFT
```
one Frame
‚îî‚îÄ‚îÄ many SubframeÔºà1msÔºâ
    ‚îî‚îÄ‚îÄ many SlotÔºàdue to numerology Ôºâ
        ‚îî‚îÄ‚îÄ many OFDM SymbolÔºànormal 14 Ôºâ
            ‚îî‚îÄ‚îÄ each Symbol It consists of N samples.Ôºàex 1024Ôºâ
```
### get_dft()
```
#define SZ_ENUM(Sz) DFT_##Sz,
typedef enum dft_size_idx {
  FOREACH_DFTSZ(SZ_ENUM)
  DFT_SIZE_IDXTABLESIZE
}  dft_size_idx_t;
- This code defines an enumeration dft_size_idx_t using macro expansion for commonly supported DFT (Discrete Fourier Transform) sizes.
- This macro takes a size (e.g., 128) and expands to: DFT_128
get_dft(256)
step 1 :static inline dft_size_idx_t get_dft(int size)
{
  switch (size) {
    FOREACH_DFTSZ(FIND_ENUM)
    default:
      LOG_E(UTIL, "function get_dft : unsupported DFT size %d\n", size);
      break;
  }
  return DFT_SIZE_IDXTABLESIZE;
}
step 2: FOREACH_DFTSZ(FIND_ENUM)
Passing FIND_ENUM as a MACRO

FIND_ENUM(128)
FIND_ENUM(256)
FIND_ENUM(512)
step 4 :FIND_ENUM(Sz)
case 128: return DFT_128; break;
case 256: return DFT_256; break;
case 512: return DFT_512; break;

step 5 :
case 256:
  return DFT_256;
  break;

step 7 :dft_size_idx_t dftsize = DFT_256;
```
```
c16_t tmp_dft_in[frame_parms->ofdm_symbol_size] __attribute__ ((aligned (32)));
This buffer is:
Used before DFT/FFT processing.
Sized according to the current numerology.
Memory-aligned to support SIMD acceleration (like AVX2, SSE, NEON).
```
- unsigned int rxdata_offset = frame_parms->get_samples_slot_timestamp(Ns,frame_parms,0);//Calculate the number of samples at the beginning of this slot
### get_samples_slot_timestamp
```
uint32_t get_samples_slot_timestamp(int slot, const NR_DL_FRAME_PARMS *fp, unsigned int sl_ahead)//PHY/INIT/nr_parms.c
{
  uint32_t samp_count = 0;

  if(!sl_ahead) {//Accumulates the number of samples from slot 0 up to slot (exclusive).
    for(unsigned int idx_slot = 0; idx_slot < slot; idx_slot++)
      samp_count += fp->get_samples_per_slot(idx_slot, fp);//Where does slot slot start in the sample buffer?"
  } else {// Accumulates the number of samples from slot slot up to slot + sl_ahead - 1.
    for (unsigned int idx_slot = slot; idx_slot < slot + sl_ahead; idx_slot++)
      samp_count += fp->get_samples_per_slot(idx_slot, fp);//What is the total number of samples across N future slots?
  }
  return samp_count;
}
know where each slot starts in the sample buffer.
| Parameter  | Description                                                                                   |
| ---------- | --------------------------------------------------------------------------------------------- |
| `slot`     | Target slot index within a frame (e.g., 0‚Äì159 for 1 ms subframes)                             |
| `fp`       | Pointer to `NR_DL_FRAME_PARMS` structure containing numerology and slot timing info           |
| `sl_ahead` | If 0, compute offset up to `slot`; if >0, sum durations of slots `[slot ... slot+sl_ahead-1]` |

Purpose
This function is used to:
Get the sample offset of slot slot from the beginning of the frame (sl_ahead == 0)
Or compute the total number of samples for multiple future slots (sl_ahead > 0)

get_samples_slot_timestamp(3, fp, 0);
// returns 3 * 3072 = 9216
```
### get_samples_per_slot
```
uint32_t get_samples_per_slot(int slot, const NR_DL_FRAME_PARMS *fp)
{
  uint32_t samp_count;

  if(fp->numerology_index == 0)//15 kHz SCS ‚Üí 1 slot = 1 subframe = 1 ms All slots have the same length.
    samp_count = fp->samples_per_subframe;
  else
    samp_count = (slot % (fp->slots_per_subframe / 2)) ? fp->samples_per_slotN0 : fp->samples_per_slot0;
//Slot durations may alternate slightly due to CP differences.
It checks whether this slot is one of the ‚Äúnormal‚Äù ones (slotN0) or the special slot0.
| Term                 | Description                                                                              |
| -------------------- | ---------------------------------------------------------------------------------------- |
| `samples_per_slot0`  | Number of samples in the **first slot** of a subframe (possibly longer due to longer CP) |
| `samples_per_slotN0` | Number of samples in all **other slots** in that subframe                                |

  return samp_count;
}
```

**unsigned int abs_symbol = Ns * frame_parms->symbols_per_slot + symbol;**
- calculate absolute symbol index
- symbols_per_slot// Number of OFDM/SC-FDMA symbols in one slot
- symbol// The symbol in the slot
- Why is this calculated?
```
Because there are many slots in a radio frame, and each slot has many symbols.
therefore we need to covert the symbol-th OFDM symbol in the Ns-th slot to the nth symbol in the entire frame

example:Ns = 2, symbols_per_slot = 14, symbol = 5
abs_symbol = 2 * 14 + 5 = 33
```

```
for (int idx_symb = Ns*frame_parms->symbols_per_slot; idx_symb <= abs_symbol; idx_symb++)
    rxdata_offset += (idx_symb%(0x7<<frame_parms->numerology_index)) ? nb_prefix_samples : nb_prefix_samples0;
  rxdata_offset += frame_parms->ofdm_symbol_size * symbol;

  // use OFDM symbol from within 1/8th of the CP to avoid ISI
  rxdata_offset -= (nb_prefix_samples / frame_parms->ofdm_offset_divisor);

example
| ÂèÉÊï∏                                                 | ÂÄº        | 
| -------------------------------------------------- | -------- | 
| `Ns`                                               | 2        | 
| `symbol`                                           | 5        | 
| `symbols_per_slot`                                 | 14       | 
| `ofdm_symbol_size`                                 | 1024     | 
| `nb_prefix_samples0`                               | 160      | 
| `nb_prefix_samples`                                | 144      | 
| `numerology_index`                                 | 0        | 
| `frame_parms->ofdm_offset_divisor`                 | 8        | 

rxdata_offset = 30720;
abs_symbol = 2 * 14 + 5 = 33;
for (idx_symb = 28; idx_symb <= 33; idx_symb++)

| idx\_symb | idx\_symb % 7 |  CP | Accumulated value  |
| --------- | ------------- | ------ | ---- |
| 28        | 0             | 160    | +160 |
| 29        | 1             | 144    | +144 |
| 30        | 2             | 144    | +144 |
| 31        | 3             | 144    | +144 |
| 32        | 4             | 144    | +144 |
| 33        | 5             | 144    | +144 |

rxdata_offset += 160 + 144*5 = 880
rxdata_offset = 30720 + 880 = 31599
rxdata_offset -= 144 / 8 = 18//Subtracting the internal CP offset to avoid ISI
rxdata_offset = 36719 - 18 = 36701

```

```
if(sample_offset > rxdata_offset) //Determine where to read data based on sample_offset
- Bypassing the end of the frame buffer
else if (((rxdata_offset - sample_offset) & 7) != 0)
- Memory misalignment
else//Ê≠£Â∏∏Â∞çÈΩäÔºåÂèØÁõ¥Êé•‰ΩøÁî® buffer

Time Index ‚Üí
[ 0   ... 140   160     ...    2208 ]
 |        |      |               |
 |        |      |<-- 2048 ----->|
 |        |  FFT start         |
 |        |                     |
 |    ‚Üê CP ‰∏≠ÂæåÊÆµ              |
 |    ‚Üë ÈÅøÈñãÂâçÊÆµ ISI ÂΩ±Èüø       |
 |
 Symbol start

dft(dftsize,
      rxdata_ptr,
      (int16_t *)&rxdataF[symbol * frame_parms->ofdm_symbol_size],
      1);
//do fft
```


